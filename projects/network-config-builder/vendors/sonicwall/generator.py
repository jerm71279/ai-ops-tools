"""
SonicWall TZ/NSa Series Configuration Generator

Generates CLI configuration scripts for SonicWall firewalls.
Supports TZ series (TZ270, TZ370, TZ470, TZ570, TZ670) and NSa series.
"""

import sys
from pathlib import Path
from typing import Dict, List

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from core.models import NetworkConfig, VLANConfig, WirelessConfig, SiteToSiteVPNConfig
from vendors.base import VendorGenerator


class SonicWallGenerator(VendorGenerator):
    """
    Configuration generator for SonicWall firewalls.
    
    Generates CLI-based configuration scripts for:
    - Interface and zone configuration
    - Network addressing
    - NAT policies
    - Firewall access rules
    - DHCP server
    - VLANs
    - Security hardening
    """
    
    vendor_name = "sonicwall"
    supported_features = [
        "routing",
        "firewall",
        "nat",
        "vpn_ipsec",
        "vpn_ssl",
        "vlan",
        "dhcp",
        "zones",
        "content_filtering"
    ]
    
    def __init__(self):
        super().__init__()
        self.interface_map = {
            'X0': 'WAN',
            'X1': 'LAN',
            'X2': 'DMZ',
            'X3': 'WLAN',
            'X4': 'DMZ2'
        }
    
    def validate_config(self, config: NetworkConfig) -> bool:
        """Validate SonicWall-specific configuration requirements"""
        # Call parent validation
        super().validate_config(config)
        
        # SonicWall-specific validations
        if config.vendor.value != 'sonicwall':
            raise ValueError("Configuration is not for SonicWall vendor")
        
        return True
    
    def generate_config(self, config: NetworkConfig) -> Dict[str, str]:
        """
        Generate SonicWall configuration scripts.
        
        Returns dict of {filename: script_content}
        """
        self.validate_config(config)
        
        scripts = {}
        
        # Main configuration script
        main_script = self._generate_main_script(config)
        scripts['sonicwall_config.cli'] = main_script
        
        # Firewall rules script (if needed)
        if config.firewall_rules:
            firewall_script = self._generate_firewall_script(config)
            scripts['sonicwall_firewall.cli'] = firewall_script
        
        # VPN script (if needed)
        if config.vpn:
            vpn_script = self._generate_vpn_script(config)
            scripts['sonicwall_vpn.cli'] = vpn_script
        
        return scripts
    
    def _generate_main_script(self, config: NetworkConfig) -> str:
        """Generate main SonicWall configuration script"""
        lines = []
        
        # Header
        lines.append(f"# ===== {config.customer.name} | {config.customer.site} =====")
        lines.append("# Generated by Multi-Vendor Network Config Builder")
        lines.append("# Vendor: SonicWall")
        lines.append("#")
        lines.append("# Configuration for SonicWall TZ/NSa Series")
        lines.append("#")
        lines.append("# IMPORTANT: Review all settings before applying to production")
        lines.append("#")
        lines.append("")
        
        # System settings
        lines.append("# System Settings")
        lines.append("configure")
        lines.append(f'hostname "{config.customer.name.replace(" ", "-")}"')
        lines.append("")
        
        # WAN Interface Configuration
        if config.wan:
            lines.extend(self._generate_wan_config(config))
        
        # LAN Interface Configuration
        if config.lan:
            lines.extend(self._generate_lan_config(config))
        
        # VLAN Configuration
        if config.vlans:
            lines.extend(self._generate_vlan_config(config))
        
        # NAT Policies
        lines.extend(self._generate_nat_config(config))
        
        # Firewall Access Rules
        lines.extend(self._generate_basic_firewall_rules(config))
        
        # Security Services
        if config.security:
            lines.extend(self._generate_security_config(config))
        
        # Save configuration
        lines.append("")
        lines.append("# Save Configuration")
        lines.append("commit")
        lines.append("exit")
        lines.append("")
        
        return "\n".join(lines)
    
    def _generate_wan_config(self, config: NetworkConfig) -> List[str]:
        """Generate WAN interface configuration"""
        lines = []
        wan = config.wan
        
        lines.append("# WAN Interface (X0)")
        lines.append("interface X0")
        
        if wan.mode == "static":
            lines.append(f"  ip {wan.ip}/{wan.netmask}")
            lines.append("  zone WAN")
            lines.append("  management https")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
            
            # Default route
            if wan.gateway:
                lines.append("# Default Route")
                lines.append(f"route 0.0.0.0/0 {wan.gateway} X0")
                lines.append("")
        
        elif wan.mode == "dhcp":
            lines.append("  ip dhcp")
            lines.append("  zone WAN")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
        
        elif wan.mode == "pppoe":
            lines.append("  pppoe")
            if hasattr(wan, 'pppoe_username') and wan.pppoe_username:
                lines.append(f'  pppoe username "{wan.pppoe_username}"')
            if hasattr(wan, 'pppoe_password') and wan.pppoe_password:
                lines.append(f'  pppoe password "{wan.pppoe_password}"')
            lines.append("  zone WAN")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
        
        # DNS Servers
        if wan.dns:
            lines.append("# DNS Servers")
            for i, dns in enumerate(wan.dns[:3], 1):  # Max 3 DNS servers
                lines.append(f"dns nameserver {i} {dns}")
            lines.append("")
        
        return lines
    
    def _generate_lan_config(self, config: NetworkConfig) -> List[str]:
        """Generate LAN interface configuration"""
        lines = []
        lan = config.lan
        
        lines.append("# LAN Interface (X1)")
        lines.append("interface X1")
        lines.append(f"  ip {lan.ip}/{lan.netmask}")
        lines.append("  zone LAN")
        lines.append("  management https ssh")
        lines.append("  no shutdown")
        lines.append("exit")
        lines.append("")
        
        # DHCP Server
        if lan.dhcp and lan.dhcp.enabled:
            lines.append("# DHCP Server for LAN")
            lines.append("dhcp-server LAN")
            lines.append(f"  pool {lan.dhcp.pool_start} {lan.dhcp.pool_end}")
            lines.append(f"  lease-time {lan.dhcp.lease_time}")
            
            if lan.dhcp.dns_servers:
                dns_list = " ".join(lan.dhcp.dns_servers)
                lines.append(f"  dns-server {dns_list}")
            
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        
        return lines
    
    def _generate_vlan_config(self, config: NetworkConfig) -> List[str]:
        """Generate VLAN configurations"""
        lines = []
        
        lines.append("# VLAN Configuration")
        
        for vlan in config.vlans:
            # Extract subnet IP and prefix
            subnet_parts = vlan.subnet.split('/')
            network_ip = subnet_parts[0]
            prefix = subnet_parts[1] if len(subnet_parts) > 1 else '24'
            
            # Calculate VLAN interface IP (typically .1 of the subnet)
            ip_parts = network_ip.split('.')
            ip_parts[3] = '1'
            vlan_ip = '.'.join(ip_parts)
            
            lines.append(f"# VLAN {vlan.id} - {vlan.name}")
            lines.append(f"interface X1:{vlan.id}")
            lines.append(f"  vlan {vlan.id}")
            lines.append(f"  ip {vlan_ip}/{prefix}")
            lines.append(f"  zone {vlan.name.upper()}")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
            
            # DHCP for VLAN
            if vlan.dhcp and vlan.dhcp_config:
                lines.append(f"# DHCP Server for VLAN {vlan.id} - {vlan.name}")
                lines.append(f"dhcp-server VLAN{vlan.id}")
                lines.append(f"  pool {vlan.dhcp_config.pool_start} {vlan.dhcp_config.pool_end}")
                lines.append(f"  lease-time {vlan.dhcp_config.lease_time}")
                
                if vlan.dhcp_config.dns_servers:
                    dns_list = " ".join(vlan.dhcp_config.dns_servers)
                    lines.append(f"  dns-server {dns_list}")
                
                lines.append("  enable")
                lines.append("exit")
                lines.append("")
        
        return lines
    
    def _generate_nat_config(self, config: NetworkConfig) -> List[str]:
        """Generate NAT policy configurations"""
        lines = []
        
        lines.append("# NAT Policies")
        lines.append("# Default NAT for LAN to WAN")
        lines.append("nat-policy NAT_LAN_to_WAN")
        lines.append("  from LAN to WAN")
        lines.append("  source any")
        lines.append("  destination any")
        lines.append("  service any")
        lines.append("  nat dynamic-ip")
        lines.append("  enable")
        lines.append("exit")
        lines.append("")
        
        # NAT for each VLAN
        for vlan in config.vlans:
            if not vlan.isolation:  # Only create NAT if not isolated (guest networks may not need NAT)
                lines.append(f"# NAT for VLAN {vlan.id} - {vlan.name}")
                lines.append(f"nat-policy NAT_VLAN{vlan.id}_to_WAN")
                lines.append(f"  from {vlan.name.upper()} to WAN")
                lines.append("  source any")
                lines.append("  destination any")
                lines.append("  service any")
                lines.append("  nat dynamic-ip")
                lines.append("  enable")
                lines.append("exit")
                lines.append("")
        
        return lines
    
    def _generate_basic_firewall_rules(self, config: NetworkConfig) -> List[str]:
        """Generate basic firewall access rules"""
        lines = []
        
        lines.append("# Firewall Access Rules")
        
        # LAN to WAN
        lines.append("# Allow LAN to WAN")
        lines.append("access-rule LAN_to_WAN")
        lines.append("  from LAN to WAN")
        lines.append("  source any")
        lines.append("  destination any")
        lines.append("  service any")
        lines.append("  action allow")
        lines.append("  enable")
        lines.append("exit")
        lines.append("")
        
        # Rules for each VLAN
        for vlan in config.vlans:
            zone_name = vlan.name.upper()
            
            # VLAN to WAN (Internet access)
            lines.append(f"# Allow {vlan.name} to WAN")
            lines.append(f"access-rule {zone_name}_to_WAN")
            lines.append(f"  from {zone_name} to WAN")
            lines.append("  source any")
            lines.append("  destination any")
            lines.append("  service any")
            lines.append("  action allow")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
            
            # Guest isolation - deny access to LAN
            if vlan.isolation:
                lines.append(f"# Deny {vlan.name} to LAN (Guest Isolation)")
                lines.append(f"access-rule {zone_name}_to_LAN_deny")
                lines.append(f"  from {zone_name} to LAN")
                lines.append("  source any")
                lines.append("  destination any")
                lines.append("  service any")
                lines.append("  action deny")
                lines.append("  enable")
                lines.append("exit")
                lines.append("")
        
        return lines
    
    def _generate_security_config(self, config: NetworkConfig) -> List[str]:
        """Generate security hardening configuration"""
        lines = []
        sec = config.security
        
        lines.append("# Security Configuration")
        
        # Admin account
        if sec.admin_username and sec.admin_password:
            lines.append("# Administrative Account")
            lines.append(f'user "{sec.admin_username}"')
            lines.append(f'  password "{sec.admin_password}"')
            lines.append("  privilege admin")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        
        # Management access restrictions
        if sec.allowed_management_ips:
            lines.append("# Management Access Restrictions")
            for ip in sec.allowed_management_ips:
                lines.append(f"management allow {ip}")
            lines.append("")
        
        # Security services
        if sec.disable_unused_services:
            lines.append("# Disable Unused Services")
            lines.append("no service http")
            lines.append("no service telnet")
            lines.append("no service snmp")
            lines.append("")
        
        return lines
    
    def _generate_firewall_script(self, config: NetworkConfig) -> str:
        """Generate advanced firewall rules script"""
        lines = []
        
        lines.append(f"# ===== Advanced Firewall Rules for {config.customer.name} =====")
        lines.append("# Generated by Multi-Vendor Network Config Builder")
        lines.append("#")
        lines.append("")
        
        lines.append("configure")
        
        for rule in config.firewall_rules:
            lines.append(f"# {rule.name}")
            lines.append(f"access-rule {rule.name.replace(' ', '_')}")
            lines.append(f"  from {rule.source_zone} to {rule.destination_zone}")
            lines.append(f"  source {rule.source}")
            lines.append(f"  destination {rule.destination}")
            lines.append(f"  service {rule.service}")
            lines.append(f"  action {rule.action}")
            if hasattr(rule, 'log') and rule.log:
                lines.append("  log enable")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        
        lines.append("commit")
        lines.append("exit")
        
        return "\n".join(lines)
    
    def _generate_vpn_script(self, config: NetworkConfig) -> str:
        """Generate VPN configuration script for site-to-site IPSec VPN"""
        lines = []

        lines.append(f"# ===== VPN Configuration for {config.customer.name} | {config.customer.site} =====")
        lines.append("# Generated by Multi-Vendor Network Config Builder")
        lines.append("# Vendor: SonicWall Site-to-Site IPSec VPN")
        lines.append("#")
        lines.append("# IMPORTANT: Both sides of the VPN tunnel must be configured with matching settings")
        lines.append("#")
        lines.append("")

        lines.append("configure")
        lines.append("")

        for vpn_config in config.vpn:
            if vpn_config.type == "site-to-site" and vpn_config.site_to_site:
                s2s = vpn_config.site_to_site
                lines.extend(self._generate_site_to_site_vpn(s2s, config))

        lines.append("commit")
        lines.append("exit")
        lines.append("")

        return "\n".join(lines)

    def _generate_site_to_site_vpn(self, s2s: SiteToSiteVPNConfig, config: NetworkConfig) -> List[str]:
        """Generate site-to-site IPSec VPN configuration"""
        lines = []
        vpn_name = s2s.name.replace(" ", "_").replace("-", "_")

        # Check if NAT VPN is enabled (for overlapping subnets)
        is_nat_vpn = getattr(s2s, 'nat_vpn', False) and s2s.local_translated and s2s.remote_translated

        # Extract network addresses for address objects
        local_net = s2s.local_network.split('/')[0]
        local_prefix = s2s.local_network.split('/')[1] if '/' in s2s.local_network else '24'
        remote_net = s2s.remote_network.split('/')[0]
        remote_prefix = s2s.remote_network.split('/')[1] if '/' in s2s.remote_network else '24'

        # Calculate netmask from prefix
        local_mask = self._prefix_to_netmask(int(local_prefix))
        remote_mask = self._prefix_to_netmask(int(remote_prefix))

        # For NAT VPN, also parse translated networks
        if is_nat_vpn:
            local_trans_net = s2s.local_translated.split('/')[0]
            local_trans_prefix = s2s.local_translated.split('/')[1] if '/' in s2s.local_translated else '24'
            local_trans_mask = self._prefix_to_netmask(int(local_trans_prefix))

            remote_trans_net = s2s.remote_translated.split('/')[0]
            remote_trans_prefix = s2s.remote_translated.split('/')[1] if '/' in s2s.remote_translated else '24'
            remote_trans_mask = self._prefix_to_netmask(int(remote_trans_prefix))

        # =====================================================
        # Address Objects
        # =====================================================
        lines.append("# =====================================================")
        lines.append("# Address Objects for VPN")
        lines.append("# =====================================================")
        lines.append("")

        # Local network address object (real network)
        lines.append(f"# Local Network (Real): {s2s.local_network}")
        lines.append(f"address-object network {vpn_name}_Local_LAN")
        lines.append(f"  network {local_net}")
        lines.append(f"  netmask {local_mask}")
        lines.append("  zone LAN")
        lines.append("exit")
        lines.append("")

        # Remote network address object (real network)
        lines.append(f"# Remote Network (Real): {s2s.remote_network}")
        lines.append(f"address-object network {vpn_name}_Remote_LAN")
        lines.append(f"  network {remote_net}")
        lines.append(f"  netmask {remote_mask}")
        lines.append("  zone VPN")
        lines.append("exit")
        lines.append("")

        # NAT VPN: Additional translated network address objects
        if is_nat_vpn:
            lines.append(f"# Local Translated Network: {s2s.local_translated}")
            lines.append(f"# (How this site appears to remote site)")
            lines.append(f"address-object network {vpn_name}_Local_Translated")
            lines.append(f"  network {local_trans_net}")
            lines.append(f"  netmask {local_trans_mask}")
            lines.append("  zone VPN")
            lines.append("exit")
            lines.append("")

            lines.append(f"# Remote Translated Network: {s2s.remote_translated}")
            lines.append(f"# (How remote site appears to this site)")
            lines.append(f"address-object network {vpn_name}_Remote_Translated")
            lines.append(f"  network {remote_trans_net}")
            lines.append(f"  netmask {remote_trans_mask}")
            lines.append("  zone VPN")
            lines.append("exit")
            lines.append("")

        # Remote gateway address object
        lines.append(f"# Remote Gateway: {s2s.peer_wan_ip}")
        lines.append(f"address-object host {vpn_name}_Remote_Gateway")
        lines.append(f"  ip {s2s.peer_wan_ip}")
        lines.append("  zone WAN")
        lines.append("exit")
        lines.append("")

        # =====================================================
        # IKE Phase 1 Proposal
        # =====================================================
        lines.append("# =====================================================")
        lines.append("# IKE Phase 1 Proposal")
        lines.append("# =====================================================")
        lines.append("")

        lines.append(f"ike-proposal {vpn_name}_IKE_Proposal")
        lines.append(f"  encryption {s2s.ike_encryption}")
        lines.append(f"  authentication {s2s.ike_authentication}")
        lines.append(f"  dh-group {s2s.ike_dh_group}")
        lines.append(f"  lifetime {s2s.ike_lifetime}")
        lines.append("exit")
        lines.append("")

        # =====================================================
        # IPSec Phase 2 Proposal
        # =====================================================
        lines.append("# =====================================================")
        lines.append("# IPSec Phase 2 Proposal")
        lines.append("# =====================================================")
        lines.append("")

        lines.append(f"ipsec-proposal {vpn_name}_IPSec_Proposal")
        lines.append(f"  protocol ESP")
        lines.append(f"  encryption {s2s.ipsec_encryption}")
        lines.append(f"  authentication {s2s.ipsec_authentication}")
        if s2s.ipsec_pfs_group and s2s.ipsec_pfs_group != "none":
            lines.append(f"  pfs dh-group {s2s.ipsec_pfs_group}")
        lines.append(f"  lifetime {s2s.ipsec_lifetime}")
        lines.append("exit")
        lines.append("")

        # =====================================================
        # VPN Policy (Site-to-Site)
        # =====================================================
        lines.append("# =====================================================")
        lines.append("# VPN Policy - Site-to-Site")
        lines.append("# =====================================================")
        lines.append("")

        lines.append(f"vpn-policy site-to-site {vpn_name}")
        lines.append(f"  ike-version {s2s.ike_version}")
        lines.append(f"  gateway {vpn_name}_Remote_Gateway")
        lines.append(f"  authentication shared-secret")
        lines.append(f'  shared-secret "{s2s.preshared_key}"')
        lines.append(f"  ike-proposal {vpn_name}_IKE_Proposal")
        lines.append(f"  ipsec-proposal {vpn_name}_IPSec_Proposal")

        # For NAT VPN, use translated networks in VPN policy
        if is_nat_vpn:
            lines.append(f"  # NAT VPN: Using translated networks for tunnel")
            lines.append(f"  local-network {vpn_name}_Local_Translated")
            lines.append(f"  remote-network {vpn_name}_Remote_Translated")
        else:
            lines.append(f"  local-network {vpn_name}_Local_LAN")
            lines.append(f"  remote-network {vpn_name}_Remote_LAN")

        if s2s.local_wan_ip:
            lines.append(f"  local-gateway {s2s.local_wan_ip}")

        if s2s.nat_traversal:
            lines.append("  nat-traversal enable")

        if s2s.dead_peer_detection:
            lines.append("  dead-peer-detection enable")
            lines.append("  dead-peer-detection interval 30")
            lines.append("  dead-peer-detection max-failures 5")

        lines.append("  keep-alive enable")

        if s2s.enabled:
            lines.append("  enable")

        lines.append("exit")
        lines.append("")

        # =====================================================
        # Firewall Access Rules for VPN Traffic
        # =====================================================
        lines.append("# =====================================================")
        lines.append("# Firewall Access Rules for VPN Traffic")
        lines.append("# =====================================================")
        lines.append("")

        if is_nat_vpn:
            # NAT VPN: Users access remote via translated addresses
            lines.append(f"# Allow LAN to Remote Site via VPN (NAT VPN)")
            lines.append(f"# Local users reach remote via {s2s.remote_translated}")
            lines.append(f"access-rule {vpn_name}_LAN_to_Remote")
            lines.append("  from LAN to VPN")
            lines.append(f"  source {vpn_name}_Local_LAN")
            lines.append(f"  destination {vpn_name}_Remote_Translated")
            lines.append("  service any")
            lines.append("  action allow")
            lines.append("  log enable")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")

            lines.append(f"# Allow Remote Site to LAN via VPN (NAT VPN)")
            lines.append(f"# Remote users reach this site via {s2s.local_translated}")
            lines.append(f"access-rule {vpn_name}_Remote_to_LAN")
            lines.append("  from VPN to LAN")
            lines.append(f"  source {vpn_name}_Remote_Translated")
            lines.append(f"  destination {vpn_name}_Local_LAN")
            lines.append("  service any")
            lines.append("  action allow")
            lines.append("  log enable")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        else:
            # Standard VPN: Direct network access
            lines.append(f"# Allow LAN to Remote Site via VPN")
            lines.append(f"access-rule {vpn_name}_LAN_to_Remote")
            lines.append("  from LAN to VPN")
            lines.append(f"  source {vpn_name}_Local_LAN")
            lines.append(f"  destination {vpn_name}_Remote_LAN")
            lines.append("  service any")
            lines.append("  action allow")
            lines.append("  log enable")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")

            lines.append(f"# Allow Remote Site to LAN via VPN")
            lines.append(f"access-rule {vpn_name}_Remote_to_LAN")
            lines.append("  from VPN to LAN")
            lines.append(f"  source {vpn_name}_Remote_LAN")
            lines.append(f"  destination {vpn_name}_Local_LAN")
            lines.append("  service any")
            lines.append("  action allow")
            lines.append("  log enable")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")

        # =====================================================
        # NAT Policies for VPN Traffic
        # =====================================================
        lines.append("# =====================================================")
        lines.append("# NAT Policies for VPN Traffic")
        lines.append("# =====================================================")
        lines.append("")

        if is_nat_vpn:
            # NAT VPN requires bidirectional NAT
            lines.append(f"# NAT VPN: Translate local network to appear as {s2s.local_translated}")
            lines.append(f"# When local ({s2s.local_network}) sends to remote translated ({s2s.remote_translated})")
            lines.append(f"# Source NAT: {s2s.local_network} -> {s2s.local_translated}")
            lines.append(f"nat-policy {vpn_name}_Outbound_NAT")
            lines.append("  from LAN to VPN")
            lines.append(f"  source {vpn_name}_Local_LAN")
            lines.append(f"  destination {vpn_name}_Remote_Translated")
            lines.append("  service any")
            lines.append(f"  nat source {vpn_name}_Local_Translated")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")

            lines.append(f"# NAT VPN: Translate incoming traffic from remote translated to local real")
            lines.append(f"# When remote translated ({s2s.remote_translated}) sends to local translated ({s2s.local_translated})")
            lines.append(f"# Destination NAT: {s2s.local_translated} -> {s2s.local_network}")
            lines.append(f"nat-policy {vpn_name}_Inbound_NAT")
            lines.append("  from VPN to LAN")
            lines.append(f"  source {vpn_name}_Remote_Translated")
            lines.append(f"  destination {vpn_name}_Local_Translated")
            lines.append("  service any")
            lines.append(f"  nat destination {vpn_name}_Local_LAN")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        else:
            # Standard VPN: No NAT for VPN traffic
            lines.append(f"# No NAT for VPN traffic (must be placed BEFORE general NAT rules)")
            lines.append(f"nat-policy {vpn_name}_NoNAT")
            lines.append("  from LAN to VPN")
            lines.append(f"  source {vpn_name}_Local_LAN")
            lines.append(f"  destination {vpn_name}_Remote_LAN")
            lines.append("  service any")
            lines.append("  nat none")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")

        return lines

    def _prefix_to_netmask(self, prefix: int) -> str:
        """Convert CIDR prefix to dotted decimal netmask"""
        mask = (0xffffffff >> (32 - prefix)) << (32 - prefix)
        return f"{(mask >> 24) & 0xff}.{(mask >> 16) & 0xff}.{(mask >> 8) & 0xff}.{mask & 0xff}"
    
    def deploy_config(self, config: NetworkConfig, device_ip: str, 
                     credentials: Dict[str, str]) -> bool:
        """
        Deploy configuration to SonicWall device via API/SSH.
        
        Not yet implemented - requires SonicWall API client.
        """
        raise NotImplementedError(
            "SonicWall deployment via API not yet implemented. "
            "Please upload generated .cli files via the web interface or SSH."
        )
