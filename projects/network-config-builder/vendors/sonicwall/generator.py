"""
SonicWall TZ/NSa Series Configuration Generator

Generates CLI configuration scripts for SonicWall firewalls.
Supports TZ series (TZ270, TZ370, TZ470, TZ570, TZ670) and NSa series.
"""

import sys
from pathlib import Path
from typing import Dict, List

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from core.models import NetworkConfig, VLANConfig, WirelessConfig
from vendors.base import VendorGenerator


class SonicWallGenerator(VendorGenerator):
    """
    Configuration generator for SonicWall firewalls.
    
    Generates CLI-based configuration scripts for:
    - Interface and zone configuration
    - Network addressing
    - NAT policies
    - Firewall access rules
    - DHCP server
    - VLANs
    - Security hardening
    """
    
    vendor_name = "sonicwall"
    supported_features = [
        "routing",
        "firewall",
        "nat",
        "vpn_ipsec",
        "vpn_ssl",
        "vlan",
        "dhcp",
        "zones",
        "content_filtering"
    ]
    
    def __init__(self):
        super().__init__()
        self.interface_map = {
            'X0': 'WAN',
            'X1': 'LAN',
            'X2': 'DMZ',
            'X3': 'WLAN',
            'X4': 'DMZ2'
        }
    
    def validate_config(self, config: NetworkConfig) -> bool:
        """Validate SonicWall-specific configuration requirements"""
        # Call parent validation
        super().validate_config(config)
        
        # SonicWall-specific validations
        if config.vendor.value != 'sonicwall':
            raise ValueError("Configuration is not for SonicWall vendor")
        
        return True
    
    def generate_config(self, config: NetworkConfig) -> Dict[str, str]:
        """
        Generate SonicWall configuration scripts.
        
        Returns dict of {filename: script_content}
        """
        self.validate_config(config)
        
        scripts = {}
        
        # Main configuration script
        main_script = self._generate_main_script(config)
        scripts['sonicwall_config.cli'] = main_script
        
        # Firewall rules script (if needed)
        if config.firewall_rules:
            firewall_script = self._generate_firewall_script(config)
            scripts['sonicwall_firewall.cli'] = firewall_script
        
        # VPN script (if needed)
        if config.vpn:
            vpn_script = self._generate_vpn_script(config)
            scripts['sonicwall_vpn.cli'] = vpn_script
        
        return scripts
    
    def _generate_main_script(self, config: NetworkConfig) -> str:
        """Generate main SonicWall configuration script"""
        lines = []
        
        # Header
        lines.append(f"# ===== {config.customer.name} | {config.customer.site} =====")
        lines.append("# Generated by Multi-Vendor Network Config Builder")
        lines.append("# Vendor: SonicWall")
        lines.append("#")
        lines.append("# Configuration for SonicWall TZ/NSa Series")
        lines.append("#")
        lines.append("# IMPORTANT: Review all settings before applying to production")
        lines.append("#")
        lines.append("")
        
        # System settings
        lines.append("# System Settings")
        lines.append("configure")
        lines.append(f'hostname "{config.customer.name.replace(" ", "-")}"')
        lines.append("")
        
        # WAN Interface Configuration
        if config.wan:
            lines.extend(self._generate_wan_config(config))
        
        # LAN Interface Configuration
        if config.lan:
            lines.extend(self._generate_lan_config(config))
        
        # VLAN Configuration
        if config.vlans:
            lines.extend(self._generate_vlan_config(config))
        
        # NAT Policies
        lines.extend(self._generate_nat_config(config))
        
        # Firewall Access Rules
        lines.extend(self._generate_basic_firewall_rules(config))
        
        # Security Services
        if config.security:
            lines.extend(self._generate_security_config(config))
        
        # Save configuration
        lines.append("")
        lines.append("# Save Configuration")
        lines.append("commit")
        lines.append("exit")
        lines.append("")
        
        return "\n".join(lines)
    
    def _generate_wan_config(self, config: NetworkConfig) -> List[str]:
        """Generate WAN interface configuration"""
        lines = []
        wan = config.wan
        
        lines.append("# WAN Interface (X0)")
        lines.append("interface X0")
        
        if wan.mode == "static":
            lines.append(f"  ip {wan.ip}/{wan.netmask}")
            lines.append("  zone WAN")
            lines.append("  management https")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
            
            # Default route
            if wan.gateway:
                lines.append("# Default Route")
                lines.append(f"route 0.0.0.0/0 {wan.gateway} X0")
                lines.append("")
        
        elif wan.mode == "dhcp":
            lines.append("  ip dhcp")
            lines.append("  zone WAN")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
        
        elif wan.mode == "pppoe":
            lines.append("  pppoe")
            if hasattr(wan, 'pppoe_username') and wan.pppoe_username:
                lines.append(f'  pppoe username "{wan.pppoe_username}"')
            if hasattr(wan, 'pppoe_password') and wan.pppoe_password:
                lines.append(f'  pppoe password "{wan.pppoe_password}"')
            lines.append("  zone WAN")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
        
        # DNS Servers
        if wan.dns:
            lines.append("# DNS Servers")
            for i, dns in enumerate(wan.dns[:3], 1):  # Max 3 DNS servers
                lines.append(f"dns nameserver {i} {dns}")
            lines.append("")
        
        return lines
    
    def _generate_lan_config(self, config: NetworkConfig) -> List[str]:
        """Generate LAN interface configuration"""
        lines = []
        lan = config.lan
        
        lines.append("# LAN Interface (X1)")
        lines.append("interface X1")
        lines.append(f"  ip {lan.ip}/{lan.netmask}")
        lines.append("  zone LAN")
        lines.append("  management https ssh")
        lines.append("  no shutdown")
        lines.append("exit")
        lines.append("")
        
        # DHCP Server
        if lan.dhcp and lan.dhcp.enabled:
            lines.append("# DHCP Server for LAN")
            lines.append("dhcp-server LAN")
            lines.append(f"  pool {lan.dhcp.pool_start} {lan.dhcp.pool_end}")
            lines.append(f"  lease-time {lan.dhcp.lease_time}")
            
            if lan.dhcp.dns_servers:
                dns_list = " ".join(lan.dhcp.dns_servers)
                lines.append(f"  dns-server {dns_list}")
            
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        
        return lines
    
    def _generate_vlan_config(self, config: NetworkConfig) -> List[str]:
        """Generate VLAN configurations"""
        lines = []
        
        lines.append("# VLAN Configuration")
        
        for vlan in config.vlans:
            # Extract subnet IP and prefix
            subnet_parts = vlan.subnet.split('/')
            network_ip = subnet_parts[0]
            prefix = subnet_parts[1] if len(subnet_parts) > 1 else '24'
            
            # Calculate VLAN interface IP (typically .1 of the subnet)
            ip_parts = network_ip.split('.')
            ip_parts[3] = '1'
            vlan_ip = '.'.join(ip_parts)
            
            lines.append(f"# VLAN {vlan.id} - {vlan.name}")
            lines.append(f"interface X1:{vlan.id}")
            lines.append(f"  vlan {vlan.id}")
            lines.append(f"  ip {vlan_ip}/{prefix}")
            lines.append(f"  zone {vlan.name.upper()}")
            lines.append("  no shutdown")
            lines.append("exit")
            lines.append("")
            
            # DHCP for VLAN
            if vlan.dhcp and vlan.dhcp_config:
                lines.append(f"# DHCP Server for VLAN {vlan.id} - {vlan.name}")
                lines.append(f"dhcp-server VLAN{vlan.id}")
                lines.append(f"  pool {vlan.dhcp_config.pool_start} {vlan.dhcp_config.pool_end}")
                lines.append(f"  lease-time {vlan.dhcp_config.lease_time}")
                
                if vlan.dhcp_config.dns_servers:
                    dns_list = " ".join(vlan.dhcp_config.dns_servers)
                    lines.append(f"  dns-server {dns_list}")
                
                lines.append("  enable")
                lines.append("exit")
                lines.append("")
        
        return lines
    
    def _generate_nat_config(self, config: NetworkConfig) -> List[str]:
        """Generate NAT policy configurations"""
        lines = []
        
        lines.append("# NAT Policies")
        lines.append("# Default NAT for LAN to WAN")
        lines.append("nat-policy NAT_LAN_to_WAN")
        lines.append("  from LAN to WAN")
        lines.append("  source any")
        lines.append("  destination any")
        lines.append("  service any")
        lines.append("  nat dynamic-ip")
        lines.append("  enable")
        lines.append("exit")
        lines.append("")
        
        # NAT for each VLAN
        for vlan in config.vlans:
            if not vlan.isolation:  # Only create NAT if not isolated (guest networks may not need NAT)
                lines.append(f"# NAT for VLAN {vlan.id} - {vlan.name}")
                lines.append(f"nat-policy NAT_VLAN{vlan.id}_to_WAN")
                lines.append(f"  from {vlan.name.upper()} to WAN")
                lines.append("  source any")
                lines.append("  destination any")
                lines.append("  service any")
                lines.append("  nat dynamic-ip")
                lines.append("  enable")
                lines.append("exit")
                lines.append("")
        
        return lines
    
    def _generate_basic_firewall_rules(self, config: NetworkConfig) -> List[str]:
        """Generate basic firewall access rules"""
        lines = []
        
        lines.append("# Firewall Access Rules")
        
        # LAN to WAN
        lines.append("# Allow LAN to WAN")
        lines.append("access-rule LAN_to_WAN")
        lines.append("  from LAN to WAN")
        lines.append("  source any")
        lines.append("  destination any")
        lines.append("  service any")
        lines.append("  action allow")
        lines.append("  enable")
        lines.append("exit")
        lines.append("")
        
        # Rules for each VLAN
        for vlan in config.vlans:
            zone_name = vlan.name.upper()
            
            # VLAN to WAN (Internet access)
            lines.append(f"# Allow {vlan.name} to WAN")
            lines.append(f"access-rule {zone_name}_to_WAN")
            lines.append(f"  from {zone_name} to WAN")
            lines.append("  source any")
            lines.append("  destination any")
            lines.append("  service any")
            lines.append("  action allow")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
            
            # Guest isolation - deny access to LAN
            if vlan.isolation:
                lines.append(f"# Deny {vlan.name} to LAN (Guest Isolation)")
                lines.append(f"access-rule {zone_name}_to_LAN_deny")
                lines.append(f"  from {zone_name} to LAN")
                lines.append("  source any")
                lines.append("  destination any")
                lines.append("  service any")
                lines.append("  action deny")
                lines.append("  enable")
                lines.append("exit")
                lines.append("")
        
        return lines
    
    def _generate_security_config(self, config: NetworkConfig) -> List[str]:
        """Generate security hardening configuration"""
        lines = []
        sec = config.security
        
        lines.append("# Security Configuration")
        
        # Admin account
        if sec.admin_username and sec.admin_password:
            lines.append("# Administrative Account")
            lines.append(f'user "{sec.admin_username}"')
            lines.append(f'  password "{sec.admin_password}"')
            lines.append("  privilege admin")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        
        # Management access restrictions
        if sec.allowed_management_ips:
            lines.append("# Management Access Restrictions")
            for ip in sec.allowed_management_ips:
                lines.append(f"management allow {ip}")
            lines.append("")
        
        # Security services
        if sec.disable_unused_services:
            lines.append("# Disable Unused Services")
            lines.append("no service http")
            lines.append("no service telnet")
            lines.append("no service snmp")
            lines.append("")
        
        return lines
    
    def _generate_firewall_script(self, config: NetworkConfig) -> str:
        """Generate advanced firewall rules script"""
        lines = []
        
        lines.append(f"# ===== Advanced Firewall Rules for {config.customer.name} =====")
        lines.append("# Generated by Multi-Vendor Network Config Builder")
        lines.append("#")
        lines.append("")
        
        lines.append("configure")
        
        for rule in config.firewall_rules:
            lines.append(f"# {rule.name}")
            lines.append(f"access-rule {rule.name.replace(' ', '_')}")
            lines.append(f"  from {rule.source_zone} to {rule.destination_zone}")
            lines.append(f"  source {rule.source}")
            lines.append(f"  destination {rule.destination}")
            lines.append(f"  service {rule.service}")
            lines.append(f"  action {rule.action}")
            if hasattr(rule, 'log') and rule.log:
                lines.append("  log enable")
            lines.append("  enable")
            lines.append("exit")
            lines.append("")
        
        lines.append("commit")
        lines.append("exit")
        
        return "\n".join(lines)
    
    def _generate_vpn_script(self, config: NetworkConfig) -> str:
        """Generate VPN configuration script"""
        lines = []
        
        lines.append(f"# ===== VPN Configuration for {config.customer.name} =====")
        lines.append("# Generated by Multi-Vendor Network Config Builder")
        lines.append("#")
        lines.append("# VPN configuration placeholder")
        lines.append("# Implement specific VPN types as needed")
        lines.append("")
        
        return "\n".join(lines)
    
    def deploy_config(self, config: NetworkConfig, device_ip: str, 
                     credentials: Dict[str, str]) -> bool:
        """
        Deploy configuration to SonicWall device via API/SSH.
        
        Not yet implemented - requires SonicWall API client.
        """
        raise NotImplementedError(
            "SonicWall deployment via API not yet implemented. "
            "Please upload generated .cli files via the web interface or SSH."
        )
